==================================================================================================================
				SYSTEM CALL MONITOR TO MONITOR SYSTEM CALL USING STATIC ANALYSIS DATA PROVIDED
==================================================================================================================
================						DEVELOPED BY ABHISHEK GHOSH					==============================
================						M.TECH RESEARCH (SYSTEMS POOL)				==============================
================						SR NO: 21091								==============================
==================================================================================================================


1. Compilation
	
	The program or executable binary can be generated by using the Makefile given. Way to compile the executables 
	is as follows (using makefile):
	
	--------------------------------------------------------------------------------------------------------------
	$ make
	g++    -c -o automata.o automata.cpp
	g++    -c -o parser.o parser.cpp
	g++    -c -o sandbox.o sandbox.cpp
	g++ -o sandbox automata.o parser.o sandbox.o
	---------------------------------------------------------------------------------------------------------------
	
	After this the final executable or the system call sandbox shall be the file named "sandbox" placed in the same
	folder.
	
2. Program Structure Division
	
	The program logic is divided into three parts mainly, each of which is implemented using 3 seperate .cpp files.
	
		a. parse.cpp
			
			Our system call sandbox needs to get the static analysis data. Which it gets in the form of dot files.
			So, the graphviz graph represented in the dot file has to converted to an equivalent in memory 
			graph data structure. For that, our parse.cpp, parses the .dot file given as input to our program and
			converts it into an equivalent in-memory graph data structure, which is to be interpreted as an NFA by
			our sandbox.
			
		b. automata.cpp
		
			The NFA traversal logic is present in this cpp file. Maintaining the instantaneous descriptions. Making
			moves, finding epsilon closure is implemented by this program.
			
		c. sandbox.cpp
		
			This program contains the logic of intercepting system calls using PTRACE system. This program, works as
			follows, takes an executable as command line argument along with the .dot file containing the static 
			analysis information, (system call policy) and then it forks a new process and execs the executable given
			and it attaches the child process with it using ptrace system call. Then it uses the parser logic to parse
			the .dot file and using the automata logic, step by step incrementally makes moves on each system call.
		
		d.	sys_call_table.h
		
			This header file contains the names of all the system call indexed by the syscall number as in the linux
			operating system. This file is used for printing the system calls on the terminal when required.
			
3. Using the System Call Sandbox
	
	The executable "sandbox" takes 2 mandatory command line arguments.
	
	a. The first argument is the path to the .dot file containing the system call policy for the program which you want to
	monitor.
	
	b. The second argument is the path to the (statically linked) executable which you want to monitor.
	
	c. Arguments 3 onward are optional and they are actually act as arguments to the executable which we want to monitor.
	
	Working example: Suppose the package System_Call_Sandbox is present in our home directory.Then we can start the 
	system call monitor along with the executable as follows:
	
	----------------------------------------------------------------------------------------------------------------------
	$./System_Call_Sandbox/Sandbox/sandbox /home/abhishek/fork_demo.dot /home/abhishek/fork_demo
	
	----------------------------------------------------------------------------------------------------------------------

